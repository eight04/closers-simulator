import {writeFile, readFile, readdir} from 'fs/promises';
import Papa from "papaparse";
import camelCase from "camelcase";

const FLOAT_SCALE = 100; // 網頁的表似乎都是小數兩位
let output = ["// this file is generated by build-data.mjs"];

for (const file of await readdir('data')) {
  if (!file.endsWith('rates.csv')) continue;
  const content = await readFile(`data/${file}`, 'utf8');
  const filename = file.slice(0, -4);
  output.push(`export const ${camelCase(filename)} = ${JSON.stringify(parseCsv(content), null, 2)};`);
}

{
  const content = await readFile("data/consume-fuels.csv", 'utf8');
  const {data} = Papa.parse(content);
  const r = {};
  for (const row of data.slice(1)) {
    r[row[0]] = Number(row[1]);
  }
  output.push(`export const consumeFuels = ${JSON.stringify(r, null, 2)};`);
}

{
  const content = await readFile("data/consume-coins.csv", 'utf8');
  const {data} = Papa.parse(content);
  const items = [];
  // list items
  for (let i = 1; i < data[0].length; i++) {
    items.push({
      name: data[0][i],
    });
  }
  // coins data
  for (const row of data.slice(1)) {
    const level = row[0];
    for (let i = 1; i < row.length; i++) {
      let v = row[i];
      if (v === '') continue;
      items[i - 1][level] = Number(v);
    }
  }
  // fill empty data
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    // linear interpolate
    let low = null;
    let high = null;
    const pending = [];
    for (let level = 0; level < 30; level++) {
      if (item[level] == null) {
        if (level === 0) {
          // FIXME: assume level 0 cost is 0 if missing
          item[level] = 0;
        } else {
          pending.push(level);
          continue;
        }
      }
      if (low === null) {
        low = {level, value: item[level]};
      } else {
        if (high !== null) {
          low = high;
        }
        high = {level, value: item[level]};
        // fill pending
        for (const l of pending) {
          const t = (l - low.level) / (high.level - low.level);
          item[l] = Math.round(low.value + t * (high.value - low.value));
        }
        pending.length = 0;
      }
    }
    if (high === null) {
      console.warn(`Cannot fill data for item ${item.name}: only one data point`);
      items.splice(i, 1);
      i--;
      continue;
    }
    // fill remaining pending
    for (const l of pending) {
      const t = (l - high.level) / (high.level - low.level);
      item[l] = Math.round(high.value + t * (high.value - low.value));
    }
  }
  output.push(`export const consumeCoins = ${JSON.stringify(items, null, 2)};`);
}

await writeFile('src/lib/data.js', output.join('\n') + '\n');

function parseCsv(content) {
  const parsed = Papa.parse(content, {
    header: true,
    skipEmptyLines: true,
    transformHeader: (h, idx) => {
      let match;
      if (h.includes("階段") && idx === 0) {
        return "level";
      } else if ((match = h.match(/[+-]\d/))) {
        return Number(match[0]).toString();
      } else if (h.includes("無變")) {
        return "0";
      } else if (h.includes("強化點數")) {
        return "pity";
      }
      return h;
    },
    transform: (value, header) => {
      if (typeof value !== 'string') {
        return value;
      }
      if (value === '') {
        return null;
      } else if (!isNaN(Number(value))) {
        return Number(value);
      } else if (value.endsWith('%')) {
        if (/\.\d{3}/.test(value)) {
          throw new Error(`Too many decimal places for ${header}: ${value}`);
        }
        return Math.round(Number(value.slice(0, -1)) * FLOAT_SCALE);
      } else if (value === "無") {
        return null;
      }
      throw new Error(`Unknown value for ${header}: ${value}`);
    }
  });
  return parsed.data.reduce((acc, row) => {
    const level = row.level;
    delete row.level;
    acc[level] = row;
    return acc;
  }, {});
}
